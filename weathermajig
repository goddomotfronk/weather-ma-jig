#!/usr/bin/env bash

#   "ozone": 348.84,
#   "pressure": 1027.55,
#   "cloudCover": 0.08,
#   "visibility": 10,
#   "windBearing": 267,
#   "windSpeed": 1.96,
#   "humidity": 0.58,
#   "dewPoint": 19.72,
#   "apparentTemperatureMaxTime": 1425679200,
#   "precipIntensityMax": 0,
#   "precipIntensity": 0,
#   "moonPhase": 0.53,
#   "sunsetTime": 1425689897,
#   "sunriseTime": 1425648477,
#   "icon": "clear-day",
#   "summary": "Clear throughout the day.",
#   "time": 1425625200,
#   "precipProbability": 0,
#   "temperatureMin": 20.53,
#   "temperatureMinTime": 1425636000,
#   "temperatureMax": 49.22,
#   "temperatureMaxTime": 1425679200,
#   "apparentTemperatureMin": 16.06,
#   "apparentTemperatureMinTime": 1425621600,
#   "apparentTemperatureMax": 49.22
show_help() {
  cat<<USE
  USAGE:
    weather-ma-jig <place>
  OPTIONS:
    --short|-s: short output
  EXAMPLE:
    weather-ma-jig Boulder
USE
}

has?() {
  command -v "$1" > /dev/null 2>&1
}

die() {
  printf "[ERROR] %s\n" "$@" >&2
  exit 1
}

# Simple calculator
function calc() {
    result="$(printf "scale=10;$*\n" | bc --mathlib | tr -d '\\\n')"
    #                       ‚îî‚îÄ default (when `--mathlib` is used) is 20
    #
    if [[ "$result" == *.* ]]; then
        # improve the output for decimal numbers
        result=$(printf "$result" |
          sed -e 's/^\./0./' -e 's/^-\./-0./' -e 's/0*$//;s/\.$//')
    fi
}

check_deps() {
  has? curl || die 'curl not found'
  has? jq || die 'jq not found try: https://stedolan.github.io/jq/'
  if (( current == 0 )); then
    has? csvlook || die 'csvlook not found try: pip install csvkit'
  fi
}

get_conf() {
  . "${XDG_CONFIG:=${HOME}/.config}/weathermajig"

  test -n "$GOOGLE_KEY" || \
    die "GOOGLE_KEY not found, check ${XDG_CONFIG:=${HOME}/.config}/weathermajig"

  test -n "$DARK_SKY_KEY" || \
    die "DARK_SKY_KEY not found, check ${XDG_CONFIG:=${HOME}/.config}/weathermajig"

  if [[ -z "$loc" || -n "$place" ]]; then
    get_lat_lng
  fi
}

grep_forecast() {
  local value=$1
  shift
  local day=-1

  (( $# > 0 )) && \
    local day=$1

  (( day == -1 )) && \
    return=$(printf "${forecast}\n" | jq -r ".currently .${value}") || \
    return=$(printf "${forecast}\n" | jq -r ".daily .data[${day}] .${value}")
}

get_geo() {
  location=$(curl -s \
    "https://maps.googleapis.com/maps/api/geocode/json?address=${place}&key=${GOOGLE_KEY}" \
    | jq '.results [0] .geometry .location')

  if [[ -z "$location" ]]; then
    die "Unable to determine location, check https://maps.googleapis.com/maps/api/geocode/json?address=${place}&key=${GOOGLE_KEY}"
  fi

  loc="$(echo "$location" | jq '.lat'),$(echo "$location" | jq '.lng')"
}

discern_geo() {
  loc="$(curl -s ipinfo.io | jq -r '.loc')"

  if [[ -z "$loc" ]]; then
    die "Unable to determine lat./long. Check ipinfo.io"
  fi
}

get_lat_lng() {
  if [[ -z "$place" ]]; then
    discern_geo
  else
    get_geo
  fi
}

setup_emoji() {
  if [[ "$(uname -s)" == "Darwin" ]]; then
    sun="üåû "
    snow="‚ùÑÔ∏è "
    rain="‚òî "
    cloud="‚õÖ "
    default="üåè "
  else
    sun="‚òÄ"
    snow="‚ùÑ"
    rain="‚òÇ"
    cloud="‚òÅ"
    default="‚úî"
  fi
}

get_current_forecast() {
  grep_forecast time
  time=$(date --date="@${return}" +'%a %D %r')

  grep_forecast temperature
  temp=$return

  grep_forecast icon
  icon=$return

  grep_forecast summary
  conditions=$return

  grep_forecast temperatureMax 0
  high=$return

  grep_forecast temperatureMin 0
  low=$return

  grep_forecast sunriseTime 0
  sunrise=$(date --date="@${return}" +'%a %D %r')

  grep_forecast sunsetTime 0
  sunset=$(date --date="@${return}" +'%a %D %r')
}

get_extended_forecast() {
  local sunrise_epoch
  local sunset_epoch

  for i in $(seq 0 ${count}); do
    grep_forecast icon $i
    icon=$return

    discern_emoji

    grep_forecast time $i
    time_arr[$i]="${emoji} $(date --date=@${return} +'%a %D')"

    grep_forecast summary $i
    conditions_arr[$i]="${return}"

    if (( summary == 0 )); then
      grep_forecast temperatureMax $i
      high_arr[$i]=$return

      grep_forecast temperatureMin $i
      low_arr[$i]=$return

      grep_forecast precipProbability $i
      calc "${return} * 100"
      precip_arr[$i]=$result

      grep_forecast humidity $i
      calc "${return} * 100"
      humid_arr[$i]=$result

      grep_forecast dewPoint $1
      dew_arr[$i]=$return

      grep_forecast sunriseTime $i
      sunrise_epoch=$return

      grep_forecast sunsetTime $i
      sunset_epoch=$return

      sunrise_arr[$i]=$(date --date="@${sunrise_epoch}" +'%r')
      sunset_arr[$i]=$(date --date="@${sunset_epoch}" +'%r')
    fi
  done
}

get_forecast() {
  forecast=$(curl -s "https://api.forecast.io/forecast/${DARK_SKY_KEY}/${loc}")

  if [[ -z "$forecast" ]]; then
    die "Unable to get forecast, checkout https://api.forecast.io/forecast/${DARK_SKY_KEY}/${loc}"
  fi

  (( current == 0 )) && get_extended_forecast
  (( current == 1 )) && get_current_forecast
}

setup_short_output() {
  # $1 = emoji
  # $2 = conditions
  # $3 = temp
  read -r -d '' output_template <<'EOF'
%s %s [%s¬∞F]\n
EOF
}

setup_long_output() {
  # Current output long
  #   $1 = date
  #   $2 = location
  #   $3 = current
  #   $4 = high
  #   $5 = low
  #   $6 = sunrise
  #   $7 = sunset
  #   $8 = emoji
  #   $9 = conditions
  read -r -d '' output_template <<'EOF'
%s
Forcast for %s
---
Currently: %s¬∞F
High: %s¬∞F
Low: %s¬∞F
Sunrise: %s
Sunset: %s
%s %s\n
EOF
}

setup_current_output() {
  (( short == 1 )) && setup_short_output
  (( short == 0 )) && setup_long_output

  discern_emoji
  echo_current_output
}

setup_extended_output() {
  local date_row='Date'
  local cond_row='Summary'
  local condition

  if (( summary == 0 )); then
    local high_row='High'
    local low_row='Low'
    local precip_row='Precip. Prob.'
    local humid_row='Humidity'
    local dew_row='Dew Point'
    local sunrise_row='Sunrise'
    local sunset_row='Sunset'
  fi

  for i in $(seq 0 ${count}); do

    condition=${conditions_arr[$i]}
    if (( summary == 0 )); then
      if (( ${#condition} > 20 )); then
        condition="${condition:0:20}‚Ä¶"
      fi

      high_row="${high_row}~${high_arr[$i]}¬∞F"
      low_row="${low_row}~${low_arr[$i]}¬∞F"
      precip_row="${precip_row}~${precip_arr[$i]}%"
      humid_row="${humid_row}~${humid_arr[$i]}%"
      dew_row="${dew_row}~${dew_arr[$i]}¬∞F"
      sunrise_row="${sunrise_row}~${sunrise_arr[$i]}"
      sunset_row="${sunset_row}~${sunset_arr[$i]}"
    fi

    date_row="${date_row}~${time_arr[$i]}"
    cond_row="${cond_row}~${condition}"
  done

  if [[ -n "$place" ]]; then
    for=${place//+/ }
  else
    for=${loc}
  fi

  printf "Forecast for %s\n" "$for"

  if (( summary == 0 )); then
    printf "%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n" \
      "${date_row}" \
      "${high_row}" \
      "${low_row}"  \
      "${precip_row}"  \
      "${humid_row}"  \
      "${dew_row}" \
      "${sunrise_row}" \
      "${sunset_row}" \
      "${cond_row}" \
      | csvlook -d~
  else
    printf "%s\n%s\n" \
      "${date_row}" \
      "${cond_row}" \
      | csvlook -d~
  fi
}

setup_output() {
  (( current == 1 )) && setup_current_output
  (( current == 0 )) && setup_extended_output
}

discern_emoji() {
  case "$icon" in
    *Sun*|*sun*)
      emoji="$sun"
      ;;
    *Snow*|*snow*)
      emoji="$snow"
      ;;
    *storm*|*Storm*|*Rain*|*rain*|*Shower*|*shower*|*Drizzle*|*drizzle*)
      emoji="$rain"
      ;;
    *Cloud*|*cloud*)
      emoji="$cloud"
      ;;
    *)
      emoji="$default"
  esac
}

echo_long_output() {
  if [[ -n "$place" ]]; then
    for=${place//+/ }
  else
    for=${loc}
  fi

  printf "$output_template" \
    "$time" \
    "$loc" \
    "$temp" \
    "$high" \
    "$low" \
    "$sunrise" \
    "$sunset" \
    "$emoji" \
    "$conditions"
}

echo_short_output() {
  if (( ${#conditions} > 10 )); then
    conditions="${conditions:0:10}‚Ä¶"
  fi

  printf "$output_template" \
    "$emoji" "$conditions" "$temp"
}

echo_current_output() {
  (( short == 0 )) && echo_long_output
  (( short == 1 )) && echo_short_output
}

manage_overrides() {
  (( summary == 1 )) && \
  (( count == 0 )) && \
    count=1

  # extended + short cannot co-exist
  (( short == 1 )) && \
  (( current == 0 )) && \
    short=0

  # summary + short cannot co-exist
  (( short == 1 )) && \
  (( summary == 1 )) && \
    short=0

  # Can only get the summary of a day
  (( summary == 1 )) && \
  (( current == 1 )) && \
    current=0

  if (( current == 0 )); then
    (( count-- ))

    if (( summary == 0 )); then
      declare -A time_arr
      declare -A high_arr
      declare -A low_arr
      declare -A precip_arr
      declare -A humid_arr
      declare -A dew_arr
      declare -A visible_arr
      declare -A cloud_arr
      declare -A pressure_arr
      declare -A ozone_arr
      declare -A sunrise_arr
      declare -A sunset_arr
      declare -A moon_arr
    fi

    declare -A conditions_arr
  fi
}

init() {
  manage_overrides
  check_deps
  get_conf
  setup_emoji
  get_forecast
  setup_output
}

check_count() {
  local check
  local digit
  digit=$1
  check=$(printf "%s\n" "$1" | tr -d [[:xdigit:]])

  if [[ -n "$check" ]]; then
    die "--extended takes a numeric argument, e.g. -e 4"
  fi

  if (( digit > 7 )); then
    die "Can't do more than 7 day forecast, bub"
  fi
}

main() {
  short=0
  current=1
  summary=0
  place=""

  while [ -n "$1" ]; do
    case "$1" in
      --short|-s)
        short=1
        ;;
      --extended|-e)
        current=0
        shift
        count=$1
        check_count $count
        ;;
      --help|-h)
        show_help
        exit 0
        ;;
      --summary|-s)
        summary=1
        ;;
      --)
        shift
        place="$@"
        break
        ;;
      *)
        place="${place}$1 "
    esac
    shift
  done

  place="${place// /+}"

  init
}

main "$@"